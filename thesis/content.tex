% !TEX root = thesis.tex
\section{Introduction}
\section{Lake-Analyzer}
\section{Foundations}
\section{Matlab WPS}
	\begin{itemize}
		\item weakly typed language
		\item functions with multiple return values
		\item previous approaches: WPS4R
		\begin{itemize}
			\item heavily format specific
			\begin{itemize}
				\item parsing of GML/etc in the WPS and translation to R structures
				\item configuration as comments in R scripts
				\item focussing on scripts and not on functions
			\end{itemize}
		\end{itemize}
	\end{itemize}
	\begin{itemize}
		\begin{figure}[!htb]
			\centering
			\includegraphics[width=.8\textwidth]{figures/sequence-diagramm-mwps.pdf}
			\caption{\label{fig:sd:mwps} Sequence diagram of the Matlab WPS.} %182x194
		\end{figure}
		\item matlab function <-> wps process
		\item not format specific
		\item no conversion of complex inputs/outputs
		\begin{itemize}
			\item single output formats
		\end{itemize}
		\item matlab program has to parse inputs
		\item easy to publish existing scripts and functions as WPS processes
		\item multi-tier implementation
		\begin{itemize}
			\item Matlab WPS
			\begin{itemize}
				\item Translates WPS Execute requests to Matlab client requests
				\item Translates Matlab client responses to WPS Execute responses
				\item configuration with YAML file to create description and translate inputs/outputs
			\end{itemize}
			\item Matlab Client
			\begin{itemize}
				\item WebSocket client to access the Matlab server.
				\item offers simple request building API
			\end{itemize}
			\item Matlab Server
			\begin{itemize}
				\item WebSocket server that pools multiple Matlab Instances
				\item delegates requests to free instances
			\end{itemize}
			\item Matlab Instance
			\begin{itemize}
				\item a Java wrapper around a Matlab instance
			\end{itemize}
			\item Matlab
			\begin{itemize}
				\item A headless instance of the Matlab software
			\end{itemize}
		\end{itemize}
	\end{itemize}
	\subsection{Configuration}
	\lstinputlisting[label={lst:matlab:example:fun},
					 caption={Matlab example function that represents a simple addition.},
					 float=!htb,language=Matlab]{listings/matlab-add-function.m}
	\lstinputlisting[label={lst:matlab:example:yaml},
					 caption={Matlab process configuration describing the function in Listing \ref{lst:matlab:example:fun}.},
					 morekeywords={function,connection,identifier,version,inputs,outputs,type},
					 float=!htb,language=YAML]{listings/matlab-add-process-configuration.yaml}
	\lstinputlisting[label={lst:matlab:example:desc},
					 caption={[Process description generated from the configuration in Listing \ref{lst:matlab:example:yaml}.]Process description generated from the configuration in Listing \ref{lst:matlab:example:yaml} (see Appendix \ref{sec:xmlnamespaces} for omitted XML namespaces).},
					 float=!htb,language=XML]{listings/matlab-add-process-description.xml}
	\begin{itemize}
		\item Can not be used to offer any function as process
		\item would not conform to Mathworks license
		\item configuring of a single function as a process
		\item configuration YAML file
	\end{itemize}


	\subsection{Type Mapping}
		\begin{table}[!htb]
			\sffamily\centering
			\caption{\label{tab:matlab:typemapping}Type Mapping between Matlab and WPS Data}
			\begin{tabular}{@{}llcc@{}}
				\toprule
				&
				& \multicolumn{2}{b}{Matlab Type}\\
				\cmidrule(l){3-4}
				\multicolumn{1}{@{}b}{}
				& \multicolumn{1}{b}{Data}
				& \multicolumn{1}{b}{For single inputs}
				& \multicolumn{1}{b@{}}{For multiple inputs}\\
				\cmidrule(rl){2-2}
				\cmidrule(rl){3-3}
				\cmidrule(l){4-4}
				\textbf{Complex}      & \textit{any} & String  & Cell \\\midrule
				\textbf{Bounding Box} & -            & -       & -    \\\midrule
				\textbf{Literal}      & xs:int       & Numeric & Array\\
									  & xs:boolean   & Numeric & Array\\
									  & xs:dateTime  & Numeric & Array\\
									  & xs:double    & Numeric & Array\\
									  & xs:float     & Numeric & Array\\
									  & xs:byte      & Numeric & Array\\
									  & xs:short     & Numeric & Array\\
									  & xs:int       & Numeric & Array\\
									  & xs:long      & Numeric & Array\\
									  & xs:string    & String  & Cell \\
									  & xs:anyURI    & String  & Cell \\
				\bottomrule
			\end{tabular}
		\end{table}
	\subsection{Pooling}
	\begin{itemize}
		\item matlab instances are pooled
		\item reduced starting time of instances
		\item limitation of instances
	\end{itemize}
	\subsection{License Issues}
		\begin{signedquote}{The MathWorks, Inc. Software License Agreement}
			4. LICENSE RESTRICTIONS.  The License is subject to the express restrictions
			set forth below. Licensee shall not, and shall not permit any Affiliate or any
			Third Party to:
				[...]
				4.8. provide access (directly or indirectly) to the Programs via a web or
				network Application, except as permitted in Article 8 of the Deployment
				Addendum;
		\end{signedquote}

		\begin{signedquote}{The MathWorks, Inc. Software License Agreement - Deployment Addendum}
			8. WEB APPLICATIONS.  Licensee may not provide access to an entire Program
			or a substantial portion of a Program by means of a web interface.

			For the Network Concurrent User Activation Type.  Programs licensed under the
			Network Concurrent User Activation Type may be called via a web application,
			provided the web application does not provide access to the MATLAB command
			line, or any of the licensed Programs with code generation capabilities.  In
			addition, Licensed Users may not provide access to an entire Program or a
			substantial portion of a Program.  Such operation of an application via a web
			interface may be provided to an unlimited number of web browser clients, at no
			additional cost, for Licensee's own use for its Internal Operations, and for
			use by Third Parties.

			For the Network Named User and Standalone Named User Activation Types.
			Programs licensed under the Network Named User and Standalone Named User
			Activation Types may be called via a web application, provided the web
			application does not provide access to the MATLAB command line, or any of the
			licensed Programs with code generation capabilities, and such application is
			only accessed by designated Network Named User or Standalone Named User
			licensees of such Programs.

			Programs licensed under any other Activation Type may not be called via a web
			interface.
		\end{signedquote}

	\subsection{Implementation}

	\subsection{Lake-Analyzer WPS}
\section{Streaming WPS}
	\begin{itemize}
		\item the concept of streaming describes the sequential processing of data in contrast to random access processing
		\item processing takes place on small chunks instead of the complete dataset
		\item reduced processing resources needed to process smaller chunks
		\item reduced latency to see the output
		\item enables processing of indefinite large datasets (e.g. live analysis)
		\item widely known:
		\begin{itemize}
			\item media streaming (live/on-demand) video/audio streaming
			\begin{itemize}
				\item RTP and RTCP \citep{ietf:rfc3550}, RTSP \citep{ietf:rfc2326}, SIP \citep{ietf:rfc3261}
			\end{itemize}
			\item inter process communication
			\begin{itemize}
				\item pipes/sockets (local or network) \citep{buschmann1996pattern}
			\end{itemize}
		\end{itemize}
		\begin{figure}[!htb]
			\centering
			\input{figures/streaming-types}
			\caption{\label{fig:streaming}Four different types of processing data: (a) conventional processing, (b) streaming input data (c) streaming output data, (d) full input and output streaming \citep[based on][]{foerster2012live}.}
		\end{figure}
		\item the system should extends the traditional processing paradigm  (see Figure \ref{fig:streaming} (a))\dots
		\begin{itemize}
			\item \dots to enable input only streaming (see Figure \ref{fig:streaming} (b))
			\begin{itemize}
				\item input should be supplied subsequently
			\end{itemize}
			\item \dots to enable output only streaming  (see Figure \ref{fig:streaming} (c))
			\begin{itemize}
				\item intermediate outputs should be published as they come available
			\end{itemize}
			\item \dots to enable full input and output streaming  (see Figure \ref{fig:streaming} (c))
			\begin{itemize}
				\item input should be supplied subsequently
				\item intermediate outputs should be published as they come available
			\end{itemize}
		\end{itemize}
		\item Many processes accept inputs that are aggregates of smaller inputs (such as rasters and tiles, feature collections and features, etc.). Often these inputs are processed separately
		\item it should\dots
		\begin{itemize}
			\item \dots not rely on inefficient polling techniques
			\item \dots be deployable in a web browser environment
			\item \dots should rely on open and widely used standards
			\item \dots be as inter operable as possible with the existing WPS standard
			\item \dots allow not only sequential analysis but should also take dependencies between spatio-temporal features into account
			\item \dots be not dependent on the data format
			\item \dots should allow live analysis of data
			\item \dots should allow analysis of great data sets
			\item \dots should allow chaining
			\item \dots should allow to easily transform existing WPS processes into streaming processes
			\item \dots should process data chunks in parallel if possible while maintaining provenance
		\end{itemize}

		\item previous approaches \citep{foerster2012live}
		\begin{itemize}
			\item in strong correlation to media streaming \citep{ietf:draft-pantos-http-live-streaming-12}
			\item publishing data chunks in playlists
			\item client/wps polling playlist and fetches data chunks when they become available
			\item big overhead of continuous fetching (in what frequency?)
			\item asynchronous WPS Execute
			\item output playlist is transported by wps:ProcessStarted: ``A human-readable text string whose contents are left open to definition by each WPS server, but is expected to include any messages the server may wish to let the clients know. Such information could include how much longer the process may take to execute, or any warning conditions that may have been encountered to date. The client may display this text to a human user.''
			\item WPS standard highly constraining
			\item approach still stick to it for the sake of interoperability
		\end{itemize}
		\item previous approach is highly limited
		\begin{itemize}
			\item implementation only supports output streaming (\ref{fig:streaming}) (c))
			\item WPS/algorithm is splitting outputs $\Rightarrow$ highly format specific
			\item splitting of complex data is often a complex procedure that can not be automated
			\item each data items context important
			\item dependencies between data chunks can not be considered
			\item automatic splitting of e.g. features in a Feature Collection is highly format dependent
			\item browser based clients can not use streaming inputs
			\item they can not offer a file under a URL
			\item multiple outputs to stream?
			\item how to connect/coordinate multiple streamed inputs?
		\end{itemize}
		\item this approach\dots
		\begin{itemize}
			\item will fulfill all above mentioned requirements
			\item break out of the constraints imposed by the WPS standard
			\item while reusing terminology and technology of the WPS standard
			\item use modern web browser compatible technologies
		\end{itemize}
		\item create a messaging based architecture
		\item use WebSockets to accomplish true full-duplex streaming of data
		\item WPS is highly XML based: use widely known SOAP+WSA on top of WebSockets
	\end{itemize}

	\subsection{Protocol}
		\begin{itemize}
			\item A streaming process is identifiable instance of a streaming enabled process
			\item core of the Streaming WPS
			\item will receive inputs process them, and emit the outputs
			\item Starting of Streaming Process by executing a WPS process
			\item after starting of a streaming process the WPS execute will return immediately
			\item WPS outputs are identifier and WebSocket URL of the streaming process
			\item providing inputs and receiving outputs over WebSockets
			\begin{figure}[!htb]
				\centering
				\includegraphics[width=.7868\textwidth]{figures/sequence-diagramm-swps.pdf} % 179x274
				\caption{\label{fig:sd:swps} Sequence diagram of the Streaming WPS.}
			\end{figure}
			\item detailed description (depicted in Figure \ref{fig:sd:swps})
			\begin{itemize}
				\item A client (Sender) issues a Execute to a streaming enables WPS process (step 1)
				\item the streaming WPS will instantiate a Streaming Process and a Delegate the will process data chunks (step 2 \& 3)
				\item The Streaming WPS returns the identifier and endpoint URL of the created Streaming Process in the ExecuteResponse
				\item One or more clients (which may also be the sender) connects to this endpoint URL and requests the outputs of the Streaming Process (step 5)
				\item One or multiple clients start sending chunks of data to the Streaming Process using Input Messages over WebSockets. The connection may stay open while feeding (step 6)
				\item the Streaming Process will check the inputs (especially whether the supplied input introduce a cycle (see section \ref{sec:stream:dependencies})) (step 8) and will enqueue them until they can be processed
				\item When the inputs can be processes the processing will be delegated to the delegate, which may or may not return a intermediate output  (step 9 \& 10)
				\item if theres is a intermediate result, the Streaming Process will push it to the listening clients (step 11)
				\item Steps 6--11 may be repeated until there are no more inputs available
				\item the sender will inform the Streaming Process by sending a stop message (step 12)
				\item the Streaming Process asks the delegate for a final result and will publish it, if is available (step 13--15)
				\item after this the Streaming Process will tell all listening clients that there will be no further outputs and will stop (step 18)
			\end{itemize}
			\item allows full input/output streaming: every input message results in a output message
			\item allows input only streaming: no intermediate outputs, only final output message
			\item allows output only streaming: even not depicted in the diagram, step 11 may be repeated
			\item multiple streaming inputs/outputs are possible
			\item encapsulated in a streaming iteration (1 InputMessage + (optional) OutputMessage)
			\item chaining of Streaming Processes possible
			\begin{figure}[!htb]
				\centering
				\includegraphics[width=\textwidth]{figures/sequence-diagramm-chain.pdf} % 179x274
				\caption{\label{fig:sd:chain} Sequence diagram of chaining two different streaming processes.}
			\end{figure}
			\begin{itemize}
				\item can be implemented as a streaming Process that simply maps input to output names
				\item requires mediator between two streaming process that translates input messages into output messages
				\item see Figure \ref{fig:sd:chain}
				\item even simpler: delegate is a WPS process chain
			\end{itemize}
		\end{itemize}
	\subsection{Messages}
		To fulfill the above defined protocol several messages have to be exchanged between sender, streaming process and receiver. In order to correlate input and outputs or to show the source of an error, the message format has to have a concept of message references. WebSockets do not have such a concept as it is only a thin layer on top of TCP, that introduces handshake and addressing mechanism to be compatible with HTTP and a minimal framing of messages. This framing is merely needed to establish a message-based instead of a stream-based protocol, as the latter would make it hard to differentiate between individual messages \citep{ietf:rfc6455}. To enable referencing of messages, and by this a asynchronous reply mechanism, another layer is needed. As the \ac{WPS} is mostly based on \ac{XML}, the message format should also be \ac{XML} based. This enables the usage of large parts of the \ac{WPS} schema and allows the reuse of many components written to interact with the \ac{WPS}.

		The widely known SOAP protocol \citep{w3c:soap1}, which may also be used as an optional binding of the \ac{WPS} and thus can be easily adopted, is a ideal candidate for this. In combination with \ac{WSA} \citep{w3c:wsa} it creates a \ac{XML} based message framework, that allows asynchronous requests and responses over a arbitrary protocol. Besides introducing a concept of addressing and routing of messages (that will not be used in the Streaming \ac{WPS}), one can assign a globally unique identifier to any message using \ac{WSA}, that can be referenced with arbitrary semantics (e.g. reply).

		The Streaming \ac{WPS} defines seven SOAP messages.

		\paragraph{Input Message}
			Input messages are used by clients to supply subsequent inputs to a streaming iteration of a streaming process. They loosely resemble a \ac{WPS} Execute request by consisting of any number of inputs and a identifier, which references the streaming process to which the inputs should be supplied. An example can be seen in Listing \ref{lst:streaming:message:input}, possible inputs can be seen in section \ref{sec:streaming:input}.
			\lstinputlisting[label={lst:streaming:message:input},
			                 caption={[Example for a Streaming WPS input message.]Example for a Streaming WPS input message (see Appendix \ref{sec:xmlnamespaces} for omitted XML namespaces).},
			                 float=!htb,language=XML]{listings/streaming-message-input.xml}
		\paragraph{Output Messages}
			Output messages are used by the streaming process to transport intermediate results at the end of a streaming iteration or a final result at the end of the streaming process to listening clients. They loosely resemble a \ac{WPS} Execute response by containing a arbitrary number of outputs and the identifier of the process, that produced the outputs. Output messages containing intermediate result are replies to their corresponding input message and reference them using \ac{WSA}. If the processing used the output of any other streaming iteration (see sections \ref{sec:stream:input:reference} and \ref{sec:stream:dependencies}) the corresponding output messages are also referenced. An example can be seen in Listing \ref{lst:streaming:message:output}.
			\lstinputlisting[label={lst:streaming:message:output},
			                 caption={[Example for a Streaming WPS output message.]Example for a Streaming WPS output message (see Appendix \ref{sec:xmlnamespaces} for omitted XML namespaces).},
			                 float=!htb,language=XML]{listings/streaming-message-output.xml}
		\paragraph{Output Request Message}
			A output request message is used by client to let a streaming process know, that it would like to receive outputs from the process. There is no direct counter part in the \ac{WPS} specification but the concept is similar to the continuous request of the \ac{WPS} response during a asynchronous process execution. As WebSockets offer a full-duplex messaging channel a continuous polling of outputs is not needed, but the streaming process can push outputs directly to listening clients. To initialize this listening the client register to one or more streaming processes using their corresponding identifiers. An example can be seen in Listing \ref{lst:streaming:message:output-request}.
			\lstinputlisting[label={lst:streaming:message:output-request},
			                 caption={[Example for a Streaming WPS output request message.]Example for a Streaming WPS output request message (see Appendix \ref{sec:xmlnamespaces} for omitted XML namespaces).},
			                 float=!htb,language=XML]{listings/streaming-message-output-request.xml}
		\paragraph{Stop Message}
			As streaming process can run indefinitely long, input supplying clients need to be able to let the streaming process know, that there will be no further inputs become available. To achieve this a stop message (see Listing \ref{lst:streaming:message:stop}) is send to the streaming process. The process will propagate the stop message to all listening clients to let them know there will be no further outputs. Before the stop message is propagated all streaming iterations, that are not yet processed will be finished but the process will not accept any further inputs. If there are still unresolved dependencies (see sections \ref{sec:stream:input:reference} and \ref{sec:stream:dependencies}) the streaming process will fail with an error message.
			\lstinputlisting[label={lst:streaming:message:stop},
			                 caption={[Example for a Streaming WPS stop message]Example for a Streaming WPS stop message (see Appendix \ref{sec:xmlnamespaces} for omitted XML namespaces).},
			                 float=!htb,language=XML]{listings/streaming-message-stop.xml}
		\paragraph{Error Message}
			Errors are transported, as in the \ac{WPS} specification, using \ac{OWS} exception reports \citep{ogc:wps}. If the delegate of a process fails or a supplied input message can not be processed due to whatever conditions, the error is propagated to listening clients. The error is always send to the client that send the message causing the error (if the client is still connected) and in case the error is caused during the execution of a streaming iteration also to all listening clients, that registered through a output request message. In contrast to failures during input validation, due to constraints imposed by dependencies (see sections \ref{sec:stream:input:reference} and \ref{sec:stream:dependencies}), errors raised during the execution of a streaming iteration can not be compensated, but will stop the streaming process. The causing message of a failure may obtained from the reply relation encoded using \ac{WSA}. An example of an error message can be found in Listing \ref{lst:streaming:message:error}.
			\lstinputlisting[label={lst:streaming:message:error},
			                 caption={[Example for a Streaming WPS error message.]Example for a Streaming WPS error message (see Appendix \ref{sec:xmlnamespaces} for omitted XML namespaces).},
			                 float=!htb,language=XML]{listings/streaming-message-error.xml}
		\paragraph{Describe \& Description Message}
			Describe messages are directly adopted from the \ac{WPS} Describe Process operation. Due to conditions described in section \ref{sec:stream:processdescription} a client needs to able to retrieve a description from a running streaming process. The message simply contains the identifier of the process the clients wants to have the description from (an example can be seen in Listing \ref{lst:streaming:message:describe}).
			\lstinputlisting[label={lst:streaming:message:describe},
							 caption={[Example for a Streaming WPS describe message.]Example for a Streaming WPS describe message (see Appendix \ref{sec:xmlnamespaces} for omitted XML namespaces).},
							 float=!htb,language=XML]{listings/streaming-message-describe.xml}
			The reply resembles a Describe Process response and is encoded in a description message referencing the describe message and containing the streaming process description and (see Listing \ref{lst:streaming:message:description}).
			\lstinputlisting[label={lst:streaming:message:description},
							 caption={[Example for a Streaming WPS description message.]Example for a Streaming WPS description message (see Appendix \ref{sec:xmlnamespaces} for omitted XML namespaces).},
							 float=!htb,language=XML]{listings/streaming-message-description.xml}

	\subsection{Input Types}
		\label{sec:streaming:input}
		The before mentioned requirements imply three different types of input for a Streaming Process. They differ in the aspect of time (when are they supplied) and scope (where are they used). Besides that all of them are based on the very same input types the \ac{WPS} standard defines:
		\paragraph{Complex Input}
			Complex data structures that can be described by a mime type, an encoding and a schema. They can represent raster data, XML structures such as GML feature collections, CSV or any type of data. This data can be supplied inline or as reference to an external HTTP resource.
		\paragraph{Literal Input}
			Data that can be represented by a single string value and can be described by data type and a unit of measurement.
		\paragraph{Bounding Box Input}
			Data that represents a multi dimensional bounding box with a associated coordinate reference system.
		\subsubsection{Streaming Inputs}
			\label{sec:streaming:input:streaming}
			The first and most obvious type of input are streaming inputs. They are provided for a single streaming iteration and will only be used in that iteration and are the core of a streaming enabled process (see Listing \ref{lst:streaming:input:streaming}).

			\lstinputlisting[label={lst:streaming:input:streaming},
			                 caption={[Example for a Streaming WPS streaming inputs.]Example for a Streaming WPS streaming inputs (see Appendix \ref{sec:xmlnamespaces} for omitted XML namespaces).},
			                 float=!htb,language=XML]{listings/streaming-input-streaming.xml}


			A traditional algorithm to compute the histogram of a raster (e.g. a satellite image) would need the complete raster as a single complex input for processing. A streaming enabled variant would split the raster in several smaller tiles and supply each of in a single input message to the streaming process. The process can process each tile on it's own and update the global histogram. Besides that the process never has to store the complete raster, it is also able to output intermediate histograms to the client.

		\subsubsection{Static Inputs}
			\label{sec:stream:input:static}
			Algorithms that operate on a streaming input often need inputs that are common to every iteration. It would be redundant and inefficient to transfer inputs like configuration parameters in every input message for every streaming iteration. For this the concept of static inputs has to be introduced. Static inputs are parameters that are supplied when a streaming process is created and apply to every streaming iteration (see Listing \ref{lst:streaming:input:static}). While the streaming process processes a streaming iteration, the static inputs are merged with the inputs of the causing input message and transparently supplied to the process's delegate. This way a conventional process can be easily converted into a streaming enabled process.

			\lstinputlisting[label={lst:streaming:input:static},
			                 caption={[Example for a Streaming WPS static inputs.]Example for a Streaming WPS static inputs (see Appendix \ref{sec:xmlnamespaces} for omitted XML namespaces).},
			                 float=!htb,language=XML]{listings/streaming-input-static.xml}

			For example a traditional process implementation of the Douglas–Peucker algorithm \citep{douglas1973algorithms} would require a feature collection and a $\epsilon$ value as inputs. In a streaming environment one would model the $\epsilon$ input as a static input supplied at process creation and stream the feature collection as single features in streaming inputs. Other examples are a coordinate transformation process, that accepts a feature collection and a target \ac{CRS} or a buffer algorithm that accepts a feature collection and a buffer size. Buffer size and \ac{CRS} would be supplied as static inputs and the feature collection would be split into several streaming inputs and supplied in independent streaming iterations.

		\subsubsection{Reference Inputs}
			\label{sec:stream:input:reference}
			While streaming offers no real benefit to algorithms that require global knowledge of the data set, there are often cases where algorithms only require knowledge about few other chunks of the dataset or even only about the result of their processing.
			\lstinputlisting[label={lst:streaming:input:reference},
			                 caption={[Example for a Streaming WPS reference input.]Example for a Streaming WPS reference input (see Appendix \ref{sec:xmlnamespaces} for omitted XML namespaces).},
			                 float=!htb,language=XML]{listings/streaming-input-reference.xml}
			\begin{itemize}
				\item see Listing \ref{lst:streaming:input:reference}
				\item references the output of a previous or upcoming streaming iteration as an input for this iteration
				\item used to model dependencies between iterations/features/etc.
				\item breaks out of the classical non-random access paradigm of streaming
				\item example: analyzing a river system where each processing of a river depends on results of rivers flowing into it
				\begin{itemize}
					\item conventional: the complete river system is a single input
					\item streaming: each river is pushed separately referencing the output of the rivers it depends on
				\end{itemize}
			\end{itemize}

		\subsubsection{Polling inputs}
			\label{sec:stream:input:polling}
			\begin{itemize}
				\item Not implemented inside the streaming WPS.
				\item what to do if multiple polling inputs are defined?
				\item how to combine them?
				\item how to define polling frequency?
				\item how to define notifications?
				\item better handled on client side (see Figure \ref{fig:sd:polling}) and transformed to streaming inputs
			\end{itemize}
			\begin{figure}[!htb]
				\centering
				\includegraphics[width=.7868\textwidth]{figures/sequence-diagramm-polling.pdf}
				% 179x274
				\caption{\label{fig:sd:polling} Sequence diagram of polling inputs of the Streaming WPS.}
			\end{figure}

	\subsection{Dependencies}
		\label{sec:stream:dependencies}
		The definition of Reference Inputs in Section \ref{sec:stream:input:reference} implies a mechanism to resolve dependencies and to order the execution of streaming iterations. These are considered as tasks and can declare dependencies to other streaming iterations either by mapping an input to the output of another streaming iteration or by declaring a explicit dependency on another streaming iteration.

		Dependencies can be best modeled using a \ac{DAG}. A \ac{DAG} is a structure $D=(V, E)$ consisting of a set of vertices (or nodes) $V$ and edges (or arcs) $E$ where every edge $e\in E$ is a ordered pair $v_1 \rightarrow v_2$ with $v_1, v_2 \in V$. The distinct vertices $v_1,\dots,v_n\in V$ are called a path if for all successive vertices $v_i, v_{i+1}$ exists a edge $v_i \rightarrow v_{i+1} \in E$. A directed graph is called acyclic if there exists no path in $G$ with $v_1 = v_n$. A subgraph of a graph is the graph $G' = (V', E')$ with $V'\subseteq V$ and $E' = \{v_1 \rightarrow v_2 \in E | v_1, v_2\in V'\}$. Two subgraphs $G_1 = (V_1, E_1), G_2 = (V_2, E_2)$ are independent if $V_1 \cap V_2 = \emptyset$ and there exists no edge $v_1\rightarrow v_2\in E$ with $v_1\in V_1 \wedge v_2\in V_2$ or $v_2\in V_1 \wedge v_1\in V_2$.

		In a dependency graph, vertices represent a task, package or other entity that has dependencies and edges represent these dependencies ($v_1$ depends on $v_2$). Dependency graphs have to be acyclic as a cycle would introduce a cyclic dependency, that can not be resolved.

		\begin{figure}[!htb]
			\centering
			\includegraphics[width=.4474\textwidth]{figures/unordered-graph.pdf} % 98x92
			\caption{\label{fig:graph:unordered} Example for a dependency graph consisting of two independent subgraphs.}
		\end{figure}

		A system containing the tasks $A, B, C, D, E, F$ and the dependencies $A\rightarrow B, A\rightarrow C, B\rightarrow D, C\rightarrow D$ and $E\rightarrow F$ will result in a \ac{DAG} consisting of two independent subgraphs (see Figure \ref{fig:graph:unordered}).

		The execution order of a dependency graph can be derived from the topological ordering of the graph: a ``topological ordering, $ord_D$, of a directed acyclic graph $D = (V, E)$ maps each vertex to a priority value such that $ord_{D}(x) < ord_{D}(y)$ holds for all edges $x \rightarrow y \in E$'' \citep{pearce2007dynamic}, a possible execution order is the list of all vertices sorted by descending $ord_D$. The topological order of a \ac{DAG} can be computed using e.g. \ac{BFS} in linear time \citep{cormen2001introduction}. In most cases the topological ordering is not unique, Figure \ref{fig:graph:ordered} shows one possible execution order for the before mentioned graph.

		\begin{figure}[!htb]
			\centering
			\includegraphics[width=1\textwidth]{figures/ordered-graph.pdf} % 219x58
			\caption{\label{fig:graph:ordered} Possible execution/topological order of the dependency graph in Figure \ref{fig:graph:unordered}. Black arrows represent dependence to another vertex, colored arrows the execution order.}
		\end{figure}

		In contrast to conventional dependency systems like package managers the Streaming \ac{WPS} can not operate on a static graph of dependencies but on a graph to which vertices and edges are added constantly. Conventional topological sorting algorithms have to recompute the ordering for every insertion from scratch which will have a big performance impact for the scenario of a great number of small streaming iterations. There exist few dynamic topological sort algorithms that will maintain the topological order across edge and node insertions and will only recompute the ordering if necessary.

		Most dependency graphs generated using the Streaming \ac{WPS} will probably consist of multiple independent subgraphs, no dependencies at all would be the most extreme example, or quite sparse graphs. For this the algorithm described by \citet{pearce2007dynamic} seems to be appropriate. Even it is theoretically it is inferior to other algorithms for dynamic topological sorting, it especially performs better on sparse graphs and on dense graphs only a constant factor slower than other algorithms \citep{pearce2007dynamic}. %wörtliches zitat?

		The actual implementation uses a \ac{DAG} only for a cyclic dependency check. Execution ordering is listener based to allow a better parallelization of streaming iterations.

		\begin{itemize}
			\item missing inputs at process stop -> failure
			\item execution failed -> process stop (dependent iterations may be affected)
		\end{itemize}

	\subsection{Process Description}
		\label{sec:stream:processdescription}
		The conventional process description mechanism of the \ac{WPS} is not sufficient to describe streaming processes.

		It consists of a \texttt{DescribeProcess} request issued to the \ac{WPS} and the retrieval of one or more process descriptions of the specified process. These descriptions contain detailed descriptions of input and output parameters of the process and information about the supported formats, units of measurement or coordinate reference systems of each parameter. They also include details about allowed values, default value and multiplicity of input parameters \citep{ogc:wps}.

		Because the Streaming \ac{WPS} uses the \ac{WPS} interface only to start a Streaming Process and the \ac{WPS} interface does not provide any extension points for process descriptions, the \texttt{DescribeProcess} operation can only be used to describe the starting process, but not the input or output parameters of a streaming process.

		In case of generic processes, e.g. processes that delegate to other \ac{WPS} processes, information about input and output parameters is not even available prior to the execution of the streaming process. Furthermore input parameter cardinalities may change due to the use of static inputs. By this a valid input parameter for a delegate process may not be used in subsequent inputs because the maximal occurrence of the parameter is already exhausted using static input parameters. By this a process description for a streaming process will always be instance specific and can not be generated by the associated \ac{WPS} process.

		With knowledge of the delegate process a client may has enough information to facilitate the streaming process but for other streaming process there is no way for a generic client to know the input parameters of the process.

		To compensate this shortcoming a method is needed to describe a Streaming Process instance at runtime.
	\subsection{Stateful vs. Stateless}
	\begin{itemize}
		\item stateful: iterative convexhull
		\item stateless: every delegating
	\end{itemize}

	\subsection{Implementation}
	\begin{itemize}
		\item Server:
		\begin{itemize}
			\item based on the 52°North WPS
			\item includeable module
			\item default implementation uses another WPS process as delegate
		\end{itemize}
		\item Client
		\begin{itemize}
			\item small JavaScript library
			\item abstracts the message generation and WebSocket interaction
			\item may be used to start generic delegation processes
		\end{itemize}
	\end{itemize}
	\subsection{Streaming Lake-Analyzer WPS}
	\begin{itemize}
		\item simple application of the Streaming WPS and \textsc{Matlab} WPS
		\item LakeAnalyzer may need further adjustments to allow live analysis
		\item remove down sampling code
		\item operate on single point in time
		\item etc
	\end{itemize}
	\subsection{Limitations}
	\begin{itemize}
		\item No input/output conversion
		\item Only default format is requested from delegate
		\item process will not fail fast in under every condition
		\begin{itemize}
			\item inputs first are checked at execution time
		\end{itemize}
		\item receivers are only provided with upcoming
		\begin{itemize}
			\item no replay queue
		\end{itemize}
	\end{itemize}
\section{Future Work}
\section{Conclusion}